<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Military GPS Dashboard</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<!-- Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Exo+2:wght@300;400;500&display=swap" rel="stylesheet">

<!-- Custom CSS -->
<link rel="stylesheet" href="style.css"/>

</head>
<body>

<!-- ============ FULL SCREEN MAP ============ -->
<div id="map"></div>

<!-- ============ TIME DISPLAY ============ -->
<div class="time-display">
  <div class="time-label">LOCAL TIME</div>
  <div class="time-value" id="currentTime">--:--:--</div>
</div>

<!-- ============ TOP CONTROL CARDS ============ -->
<div class="top-bar">
  <!-- DEVICES CARD -->
  <div class="control-card collapsed" id="devicesCard">
    <div class="card-header" onclick="toggleCard('devicesCard')">
      <div class="header-content">
        <div class="header-icon">üì±</div>
        <div class="header-text">
          <div class="card-title">DEVICES <span id="deviceCount">0</span></div>
          <div class="card-subtitle">Active trackers</div>
        </div>
      </div>
      <button class="toggle-btn">‚ñº</button>
    </div>
    <div class="card-content">
      <div class="search-box">
        <input type="text" class="search-input" id="deviceSearch" placeholder="Search devices...">
      </div>
      <div class="device-list" id="deviceList">
        <!-- Devices will be populated here -->
      </div>
    </div>
  </div>

  <!-- ROUTES CARD -->
  <div class="control-card collapsed" id="routesCard">
    <div class="card-header" onclick="toggleCard('routesCard')">
      <div class="header-content">
        <div class="header-icon">üìç</div>
        <div class="header-text">
          <div class="card-title">ROUTES</div>
          <div class="card-subtitle">Set checkpoints</div>
        </div>
      </div>
      <button class="toggle-btn">‚ñº</button>
    </div>
    <div class="card-content">
      <div class="route-form">
        <div class="form-group">
          <div class="form-label">
            <span>üè¥</span>
            <span>CHECKPOINT COORDINATES</span>
          </div>
          
          <div class="coordinate-inputs">
            <div>
              <input type="number" class="coord-input" id="latDeg" placeholder="00" min="0" max="90">
              <div class="coord-label">Deg</div>
            </div>
            <div>
              <input type="number" class="coord-input" id="latMin" placeholder="00" min="0" max="59">
              <div class="coord-label">Min</div>
            </div>
            <div>
              <input type="number" class="coord-input" id="latSec" placeholder="00.000" step="0.001">
              <div class="coord-label">Sec</div>
            </div>
          </div>
          
          <div class="direction-select">
            <div class="dir-btn active" data-dir="N" onclick="setDirection('N')">N</div>
            <div class="dir-btn" data-dir="S" onclick="setDirection('S')">S</div>
          </div>
        </div>

        <div class="form-group">
          <div class="coordinate-inputs">
            <div>
              <input type="number" class="coord-input" id="lngDeg" placeholder="000" min="0" max="180">
              <div class="coord-label">Deg</div>
            </div>
            <div>
              <input type="number" class="coord-input" id="lngMin" placeholder="00" min="0" max="59">
              <div class="coord-label">Min</div>
            </div>
            <div>
              <input type="number" class="coord-input" id="lngSec" placeholder="00.000" step="0.001">
              <div class="coord-label">Sec</div>
            </div>
          </div>
          
          <div class="direction-select">
            <div class="dir-btn active" data-dir="E" onclick="setDirection('E')">E</div>
            <div class="dir-btn" data-dir="W" onclick="setDirection('W')">W</div>
          </div>
        </div>

        <div class="form-group">
          <div class="form-label">
            <span>üè∑Ô∏è</span>
            <span>CHECKPOINT LABEL</span>
          </div>
          <input type="text" class="search-input" id="checkpointLabel" placeholder="Enter checkpoint name">
        </div>

        <div class="form-group">
          <div class="form-label">
            <span>üì±</span>
            <span>ASSIGN TO DEVICE</span>
          </div>
          <select class="device-select" id="deviceSelect">
            <option value="">All Devices</option>
            <!-- Devices will be populated here -->
          </select>
        </div>

        <div class="form-actions">
          <button class="btn btn-primary" onclick="addCheckpoint()">
            ADD CHECKPOINT
          </button>
          <button class="btn btn-secondary" onclick="addAtMapCenter()">
            MAP CENTER
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- STATS CARD -->
  <div class="control-card collapsed" id="statsCard">
    <div class="card-header" onclick="toggleCard('statsCard')">
      <div class="header-content">
        <div class="header-icon">üìä</div>
        <div class="header-text">
          <div class="card-title">STATS</div>
          <div class="card-subtitle">System overview</div>
        </div>
      </div>
      <button class="toggle-btn">‚ñº</button>
    </div>
    <div class="card-content">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-icon">üì±</div>
          <div class="stat-number" id="activeDevices">0</div>
          <div class="stat-label-large">ACTIVE</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">üè¥</div>
          <div class="stat-number" id="totalCheckpoints">0</div>
          <div class="stat-label-large">CHECKPOINTS</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">‚úÖ</div>
          <div class="stat-number" id="completedTasks">0</div>
          <div class="stat-label-large">COMPLETED</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">‚è≥</div>
          <div class="stat-number" id="remainingTasks">0</div>
          <div class="stat-label-large">REMAINING</div>
        </div>
      </div>

      <div class="stat-breakdown">
        <div class="breakdown-item">
          <span class="breakdown-label">Online Devices</span>
          <span class="breakdown-value" id="onlineDevices">0</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Offline Devices</span>
          <span class="breakdown-value" id="offlineDevices">0</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Geofences</span>
          <span class="breakdown-value" id="geofenceCount">0</span>
        </div>

        <!-- REPLACED: avg speed -> overall progress -->
        <div class="breakdown-item">
          <span class="breakdown-label">Progress</span>
          <span class="breakdown-value" id="progressPercent">0%</span>
        </div>
        <div class="breakdown-item" style="padding-top:8px;">
          <div style="background:rgba(255,255,255,0.06);height:8px;border-radius:6px;overflow:hidden;">
            <div id="overallProgress" style="height:8px;width:0%;background:linear-gradient(90deg,var(--success),var(--accent));"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ============ MAP CONTROLS ============ -->
<div class="map-controls">
  <div class="map-btn" onclick="centerOnSelectedDevice()" title="Center on selected device">
    <span>üìç</span>
  </div>
  <div class="map-btn" onclick="map.zoomIn()" title="Zoom in">
    <span>‚ûï</span>
  </div>
  <div class="map-btn" onclick="map.zoomOut()" title="Zoom out">
    <span>‚ûñ</span>
  </div>
  <div class="map-btn" onclick="showAllDevices()" title="Show all devices">
    <span>üëÅÔ∏è</span>
  </div>
  <div class="map-btn" id="focusBtn" onclick="focusOnSelectedDevice()" title="Focus selected device">
    <span id="focusBtnIcon">üéØ</span>
  </div>
  <div class="map-btn" onclick="openReportModal()" title="Mission Report">
    <span>üìÑ</span>
  </div>
</div>

<!-- ============ LEFT SIDEBAR - DEVICE DISTANCES ============ -->
<div class="left-sidebar collapsed" id="distanceSidebar">
  <div class="sidebar-header" onclick="toggleSidebar('distanceSidebar')">
    <div class="sidebar-title">üß≠ DISTANCES</div>
    <button class="toggle-btn">‚ñ∂</button>
  </div>
  <div class="sidebar-content">
    <div class="search-box">
      <input type="text" class="search-input" id="distanceSearch" placeholder="Search distances...">
    </div>
    <div class="distance-list" id="distanceList">
      <!-- Devices with distances will be populated here -->
    </div>
  </div>
</div>

<!-- ============ LEFT SIDEBAR - MISSION TIMELINE ============ -->
<div class="left-sidebar collapsed timeline-panel" id="timelinePanel">
  <div class="sidebar-header" onclick="toggleSidebar('timelinePanel')">
    <div class="sidebar-title">üßæ TIMELINE</div>
    <button class="toggle-btn">‚ñ∂</button>
  </div>
  <div class="sidebar-content">
    <div class="search-box">
      <input type="text" class="search-input" id="timelineSearch" placeholder="Search timeline...">
    </div>
    <div class="timeline-list" id="timelineList"></div>
  </div>
</div>

<!-- ============ LEFT SIDEBAR - MAP LAYERS ============ -->
<div class="left-sidebar collapsed layers-panel" id="layersSidebar">
  <div class="sidebar-header" onclick="toggleSidebar('layersSidebar')">
    <div class="sidebar-title">üõ∞Ô∏è MAP LAYERS</div>
    <button class="toggle-btn">‚ñ∂</button>
  </div>
  <div class="sidebar-content">
    <div class="layers-group">
      <button class="layer-btn active" data-layer="Satellite" onclick="setBaseLayer('Satellite')">Satellite</button>
      <button class="layer-btn" data-layer="Terrain" onclick="setBaseLayer('Terrain')">Terrain</button>
      <button class="layer-btn" data-layer="Night Ops" onclick="setBaseLayer('Night Ops')">Night Ops</button>
    </div>
    <label class="layer-toggle">
      <input type="checkbox" onchange="toggleGridOverlay(this.checked)">
      <span>Grid Overlay</span>
    </label>
  </div>
</div>

<!-- ============ REPORT MODAL ============ -->
<div class="report-modal" id="reportModal" style="display:none;">
  <div class="report-modal-content">
    <div class="report-modal-header">
      <div class="report-modal-title">MISSION SUMMARY</div>
      <button class="report-close" onclick="closeReportModal()">Close</button>
    </div>
    <div class="report-modal-body" id="reportContent">
      <!-- Report preview injected here -->
    </div>
    <div class="report-modal-footer">
      <button class="btn btn-secondary" onclick="closeReportModal()">Cancel</button>
      <button class="btn btn-secondary" onclick="exportFirebaseJson()">Export DB (JSON)</button>
      <button class="btn btn-primary" onclick="downloadReportPdf()">Download Report (PDF)</button>
    </div>
  </div>
</div>

<script>
// ============ INITIALIZATION ============
const OFFLINE_MS = 30000;
let selectedDevice = null;
const devices = {};
const flags = {};
let lastClickTime = 0;
let reportWindow = null;
let focusMode = false;
let focusedDevice = null;

// Diagnostic function to check Firebase connection
function checkFirebaseStatus() {
  console.log('üîç Firebase Diagnostic Check:');
  console.log('- Firebase initialized:', firebase && firebase.apps && firebase.apps.length > 0);
  console.log('- Database reference:', db);
  console.log('- Devices in memory:', Object.keys(devices));
  console.log('- Device count:', Object.keys(devices).length);
  
  // Try to read devices directly
  db.ref('devices').once('value').then(snap => {
    const data = snap.val();
    console.log('‚úÖ Direct Firebase read successful');
    console.log('- Raw device data:', data);
    console.log('- Device names:', Object.keys(data || {}));
  }).catch(err => {
    console.error('‚ùå Failed to read from Firebase:', err);
  });
}

// Make it globally accessible for debugging
window.checkFirebaseStatus = checkFirebaseStatus;

// Initialize map
const map = L.map('map').setView([-2.0, 30.1], 13);

const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Tiles ¬© Esri'
});

const terrainLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
  maxZoom: 17,
  attribution: 'Tiles ¬© OpenTopoMap (CC-BY-SA)'
});

const nightOpsLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  maxZoom: 19,
  attribution: 'Tiles ¬© CARTO'
});

const gridOverlay = L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner-lines/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: 'Lines ¬© Stamen'
});

const baseLayers = {
  Satellite: satelliteLayer,
  Terrain: terrainLayer,
  'Night Ops': nightOpsLayer
};

let currentBaseLayer = 'Satellite';
satelliteLayer.addTo(map);

function setBaseLayer(name) {
  if (!baseLayers[name]) return;
  if (currentBaseLayer && baseLayers[currentBaseLayer]) {
    map.removeLayer(baseLayers[currentBaseLayer]);
  }
  currentBaseLayer = name;
  baseLayers[name].addTo(map);
  document.querySelectorAll('.layer-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.layer === name);
  });
}

function toggleGridOverlay(checked) {
  if (checked) gridOverlay.addTo(map);
  else map.removeLayer(gridOverlay);
}

// ============ FIREBASE CONFIG ============
const firebaseConfig = {
  apiKey: "AIzaSyBqgUJGP2orVBT-jLzcGtkG_d_JK0qNNh8",
  authDomain: "tracker-6c988.firebaseapp.com",
  databaseURL: "https://tracker-6c988-default-rtdb.firebaseio.com",
  projectId: "tracker-6c988",
  storageBucket: "tracker-6c988.appspot.com",
  messagingSenderId: "339384342086",
  appId: "1:339384342086:web:89e763dbc43a85d3ab5c47",
  measurementId: "G-WEFZ7RXYE1"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// ============ TIME DISPLAY ============
function updateTime() {
  const now = new Date();
  const timeString = now.toLocaleTimeString();
  document.getElementById('currentTime').textContent = timeString;
}
setInterval(updateTime, 1000);
updateTime();

// ============ CARD MANAGEMENT ============
function toggleCard(cardId) {
  const now = Date.now();
  if (now - lastClickTime < 300) return; // Prevent double click
  lastClickTime = now;
  
  const card = document.getElementById(cardId);
  const btn = card.querySelector('.toggle-btn');
  
  // Collapse all other cards
  document.querySelectorAll('.control-card').forEach(otherCard => {
    if (otherCard.id !== cardId && otherCard.classList.contains('expanded')) {
      otherCard.classList.remove('expanded');
      otherCard.classList.add('collapsed');
      otherCard.querySelector('.toggle-btn').textContent = '‚ñº';
    }
  });
  
  // Toggle current card
  if (card.classList.contains('collapsed')) {
    card.classList.remove('collapsed');
    card.classList.add('expanded');
    btn.textContent = '‚ñ≤';
  } else {
    card.classList.remove('expanded');
    card.classList.add('collapsed');
    btn.textContent = '‚ñº';
  }
}

// Close card when clicking outside
document.addEventListener('click', function(event) {
  if (!event.target.closest('.control-card') && 
      !event.target.closest('.map-controls') && 
      !event.target.closest('.time-display')) {
    document.querySelectorAll('.control-card').forEach(card => {
      if (card.classList.contains('expanded')) {
        card.classList.remove('expanded');
        card.classList.add('collapsed');
        card.querySelector('.toggle-btn').textContent = '‚ñº';
      }
    });
  }
});

// ============ COORDINATE MANAGEMENT ============
let latDirection = 'N';
let lngDirection = 'E';

function setDirection(direction) {
  if (direction === 'N' || direction === 'S') {
    latDirection = direction;
    document.querySelectorAll('[data-dir="N"], [data-dir="S"]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector(`[data-dir="${direction}"]`).classList.add('active');
  } else {
    lngDirection = direction;
    document.querySelectorAll('[data-dir="E"], [data-dir="W"]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector(`[data-dir="${direction}"]`).classList.add('active');
  }
}

function convertToDecimal(deg, min, sec, direction) {
  let decimal = parseFloat(deg) + parseFloat(min)/60 + parseFloat(sec)/3600;
  if (direction === 'S' || direction === 'W') {
    decimal = -decimal;
  }
  return decimal;
}

function addCheckpoint() {
  const latDeg = document.getElementById('latDeg').value;
  const latMin = document.getElementById('latMin').value;
  const latSec = document.getElementById('latSec').value;
  const lngDeg = document.getElementById('lngDeg').value;
  const lngMin = document.getElementById('lngMin').value;
  const lngSec = document.getElementById('lngSec').value;
  const label = document.getElementById('checkpointLabel').value.trim() || 'Checkpoint';
  const deviceId = document.getElementById('deviceSelect').value;
  
  if (!latDeg || !latMin || !latSec || !lngDeg || !lngMin || !lngSec) {
    alert('Please enter all coordinate values');
    return;
  }
  
  const lat = convertToDecimal(latDeg, latMin, latSec, latDirection);
  const lng = convertToDecimal(lngDeg, lngMin, lngSec, lngDirection);
  
  const checkpointData = {
    lat: lat,
    lng: lng,
    label: label,
    seq: Date.now(),
    timestamp: new Date().toISOString()
  };
  
  if (!deviceId) {
    alert('Select a device to assign this checkpoint');
    return;
  }
  
  // Push into routes/{deviceId}/default/checkpoints
  db.ref(`routes/${deviceId}/default/checkpoints`).push(checkpointData)
    .then(() => {
      // Clear form
      document.getElementById('checkpointLabel').value = '';
      document.getElementById('latDeg').value = '';
      document.getElementById('latMin').value = '';
      document.getElementById('latSec').value = '';
      document.getElementById('lngDeg').value = '';
      document.getElementById('lngMin').value = '';
      document.getElementById('lngSec').value = '';
      updateStats();
    })
    .catch(err => console.error('Failed to add checkpoint', err));
}

function addAtMapCenter() {
  const center = map.getCenter();
  
  // Convert to DMS
  const lat = Math.abs(center.lat);
  const latDeg = Math.floor(lat);
  const latMin = Math.floor((lat - latDeg) * 60);
  const latSec = ((lat - latDeg - latMin/60) * 3600).toFixed(3);
  
  const lng = Math.abs(center.lng);
  const lngDeg = Math.floor(lng);
  const lngMin = Math.floor((lng - lngDeg) * 60);
  const lngSec = ((lng - lngDeg - lngMin/60) * 3600).toFixed(3);
  
  document.getElementById('latDeg').value = latDeg;
  document.getElementById('latMin').value = latMin;
  document.getElementById('latSec').value = latSec;
  document.getElementById('lngDeg').value = lngDeg;
  document.getElementById('lngMin').value = lngMin;
  document.getElementById('lngSec').value = lngSec;
  
  // Set directions
  setDirection(center.lat >= 0 ? 'N' : 'S');
  setDirection(center.lng >= 0 ? 'E' : 'W');
}

// ============ GEOFENCE DRAWING (right-click) ============
let drawingGeofence = false;
let gfCoords = [];
let gfLayer = null;

// create finish/cancel UI buttons
(function createGeofenceControls(){
  const container = document.createElement('div');
  container.id = 'geofenceControls';
  container.style = 'position:fixed;left:20px;bottom:20px;z-index:1100;display:flex;gap:8px;';
  container.innerHTML = `
    <button id="finishGeofenceBtn" style="display:none;padding:8px 10px;background:#00ff9d;color:#001a33;border:none;border-radius:6px;cursor:pointer;font-weight:600;box-shadow:0 0 10px rgba(0,255,157,0.35);">Finish Geofence</button>
    <button id="cancelGeofenceBtn" style="display:none;padding:8px 10px;background:#ff3d71;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;box-shadow:0 0 10px rgba(255,61,113,0.35);">Cancel</button>
    <button id="pickCPBtn" style="padding:8px 12px;background:linear-gradient(90deg,rgba(0,230,255,0.28),rgba(0,255,157,0.18));border:1px solid var(--accent);color:var(--accent);border-radius:6px;cursor:pointer;font-weight:700;letter-spacing:0.3px;box-shadow:0 0 12px rgba(0,230,255,0.25);">üó∫Ô∏è Draw Geofence</button>
    <button id="toggleGeofenceBtn" style="padding:8px 12px;background:rgba(10,20,35,0.85);border:1px solid rgba(0,230,255,0.35);color:#9fefff;border-radius:6px;cursor:pointer;font-weight:600;letter-spacing:0.2px;">Hide Geofences</button>
  `;
  document.body.appendChild(container);
  
  document.getElementById('finishGeofenceBtn').addEventListener('click', () => {
    if (gfCoords.length < 3) { alert('Need at least 3 vertices'); return; }
    const name = prompt('Geofence name:', 'Geofence') || 'Geofence';
    db.ref('geofences').push({ name, coords: gfCoords, timestamp: new Date().toISOString() })
      .then(() => {
        drawingGeofence = false;
        document.getElementById('finishGeofenceBtn').style.display = 'none';
        document.getElementById('cancelGeofenceBtn').style.display = 'none';
        if (gfLayer) { gfLayer.bindPopup(name); gfLayer = null; }
        gfCoords = [];
        updateStats();
      });
  });
  
  document.getElementById('cancelGeofenceBtn').addEventListener('click', () => {
    drawingGeofence = false;
    if (gfLayer) { map.removeLayer(gfLayer); gfLayer = null; }
    gfCoords = [];
    document.getElementById('finishGeofenceBtn').style.display = 'none';
    document.getElementById('cancelGeofenceBtn').style.display = 'none';
  });
  
  document.getElementById('pickCPBtn').addEventListener('click', () => {
    if (!drawingGeofence) {
      drawingGeofence = true;
      gfCoords = [];
      if (gfLayer) { map.removeLayer(gfLayer); gfLayer = null; }
      document.getElementById('finishGeofenceBtn').style.display = 'inline-block';
      document.getElementById('cancelGeofenceBtn').style.display = 'inline-block';
      alert('Geofence drawing started. Right-click on map to add vertices. Click Finish to save.');
    }
  });

  document.getElementById('toggleGeofenceBtn').addEventListener('click', (e) => {
    const btn = e.currentTarget;
    setGeofenceVisibility(!showGeofences);
    btn.textContent = showGeofences ? 'Hide Geofences' : 'Show Geofences';
  });
})();

// right-click handler for geofence vertices
map.on('contextmenu', function(e) {
  if (drawingGeofence) {
    // Add vertex to geofence
    gfCoords.push([e.latlng.lat, e.latlng.lng]);
    if (gfLayer) {
      gfLayer.setLatLngs(gfCoords);
    } else {
      gfLayer = L.polygon(gfCoords, { 
        color: '#ff3d71', 
        fillOpacity: 0.12,
        weight: 2,
        opacity: 0.85,
        dashArray: '6 6'
      }).addTo(map);
    }
  } else {
    // Original checkpoint coordinate filling behavior
    const lat = Math.abs(e.latlng.lat);
    const latDeg = Math.floor(lat);
    const latMin = Math.floor((lat - latDeg) * 60);
    const latSec = ((lat - latDeg - latMin/60) * 3600).toFixed(3);
    
    const lng = Math.abs(e.latlng.lng);
    const lngDeg = Math.floor(lng);
    const lngMin = Math.floor((lng - lngDeg) * 60);
    const lngSec = ((lng - lngDeg - lngMin/60) * 3600).toFixed(3);
    
    document.getElementById('latDeg').value = latDeg;
    document.getElementById('latMin').value = latMin;
    document.getElementById('latSec').value = latSec;
    document.getElementById('lngDeg').value = lngDeg;
    document.getElementById('lngMin').value = lngMin;
    document.getElementById('lngSec').value = lngSec;
    
    setDirection(e.latlng.lat >= 0 ? 'N' : 'S');
    setDirection(e.latlng.lng >= 0 ? 'E' : 'W');
    
    // Expand routes card
    toggleCard('routesCard');
  }
});


// --- caches for quick lookup ---
const geofencesCache = {};    // { gfId: { name, coords } }
const routesCache = {};      // { deviceId: { checkpoints: { cpId: {lat,lng,label,seq} }, ordered: [...] } }

// cache device coordinate history to avoid repeated DB reads
const historiesCache = {}; // { deviceName: { ts: number, points: [{lat,lng},...] } }
const HISTORY_TTL = 30_000; // ms - refresh history after this

function toNumber(value) {
  const n = typeof value === 'number' ? value : Number(value);
  return Number.isFinite(n) ? n : null;
}

function coerceCoord(raw) {
  if (!raw) return null;
  const lat = toNumber(raw.lat);
  const lng = toNumber(raw.lng);
  if (lat === null || lng === null) return null;
  const t = toNumber(raw.t);
  const spd = toNumber(raw.spd ?? raw.speed);
  const hdop = toNumber(raw.hdop);
  const alt = toNumber(raw.alt);
  return {
    lat,
    lng,
    t,
    spd,
    speed: spd,
    hdop,
    alt,
    timestamp: raw.timestamp
  };
}

function coordSortValue(coord, fallbackIndex) {
  const t = toNumber(coord.t);
  if (t !== null) return t;
  if (coord.timestamp) {
    const ts = Date.parse(coord.timestamp);
    if (!Number.isNaN(ts)) return ts;
  }
  return fallbackIndex;
}

async function fetchHistory(deviceName) {
  const now = Date.now();
  const cached = historiesCache[deviceName];
  if (cached && (now - cached.ts) < HISTORY_TTL) return cached.points;
  try {
    const devSnap = await db.ref(`devices/${deviceName}`).once('value');
    const devVal = devSnap.val() || {};

    let points = [];
    const flat = coerceCoord(devVal);
    if (flat) {
      points = [{ lat: flat.lat, lng: flat.lng }];
    } else {
      const children = Object.values(devVal)
        .map((p, idx) => {
          const c = coerceCoord(p);
          return c ? { lat: c.lat, lng: c.lng, _sort: coordSortValue(c, idx) } : null;
        })
        .filter(Boolean)
        .sort((a, b) => a._sort - b._sort);
      points = children.map(p => ({ lat: p.lat, lng: p.lng }));
    }

    historiesCache[deviceName] = { ts: now, points };
    return points;
  } catch (e) {
    console.error('fetchHistory error', e);
    historiesCache[deviceName] = { ts: now, points: [] };
    return [];
  }
}

// Compute global completion across all checkpoints.
// Completed = any device currently within radius OR any device history contains proximity within radius.
async function computeGlobalCompletion(radiusM = 10) {
  // collect all checkpoints
  const cps = []; // { cpId, deviceRouteId, lat, lng }
  for (const deviceId in routesCache) {
    const cobj = routesCache[deviceId].checkpoints || {};
    for (const cpId in cobj) {
      const cp = cobj[cpId];
      cps.push({ cpId, assignedDevice: deviceId, lat: cp.lat, lng: cp.lng });
    }
  }
  const total = cps.length;
  if (total === 0) return { total: 0, completed: 0, remaining: 0, pct: 0 };

  // quick check against current device positions
  const completedSet = new Set();
  for (const deviceName in devices) {
    const dev = devices[deviceName];
    const dLat = dev.data?.lat;
    const dLng = dev.data?.lng;
    if (typeof dLat !== 'number' || typeof dLng !== 'number') continue;
    for (let i = 0; i < cps.length; i++) {
      if (completedSet.has(i)) continue;
      const cp = cps[i];
      if (distanceMeters(dLat, dLng, cp.lat, cp.lng) <= radiusM) {
        completedSet.add(i);
      }
    }
  }

  // For remaining checkpoints, check device histories (fetch each device history once)
  if (completedSet.size < total) {
    // prepare history per device
    const deviceNames = Object.keys(devices);
    const historyPromises = deviceNames.map(n => fetchHistory(n).then(points => ({ name: n, points })));
    const histories = await Promise.all(historyPromises);

    for (let i = 0; i < cps.length; i++) {
      if (completedSet.has(i)) continue;
      const cp = cps[i];
      // check every device history for proximity
      for (const h of histories) {
        const points = h.points;
        for (const hp of points) {
          if (distanceMeters(hp.lat, hp.lng, cp.lat, cp.lng) <= radiusM) {
            completedSet.add(i);
            break;
          }
        }
        if (completedSet.has(i)) break;
      }
    }
  }

  const completed = completedSet.size;
  const remaining = total - completed;
  const pct = total > 0 ? Math.round((completed / total) * 100) : 0;
  return { total, completed, remaining, pct };
}

// Replace previous updateStats with async version that updates global numbers & progress bar
let updateStatsTimeout = null;

// ============ SIDEBAR MANAGEMENT ============
function toggleSidebar(sidebarId) {
  const sidebar = document.getElementById(sidebarId);
  const btn = sidebar.querySelector('.toggle-btn');
  
  if (sidebar.classList.contains('collapsed')) {
    sidebar.classList.remove('collapsed');
    sidebar.classList.add('expanded');
    btn.textContent = '‚óÄ';
  } else {
    sidebar.classList.remove('expanded');
    sidebar.classList.add('collapsed');
    btn.textContent = '‚ñ∂';
  }
}

// ============ DISTANCE TRACKING ============
// Calculate distance between two points in kilometers (Haversine formula)
function calculateDistance(lat1, lng1, lat2, lng2) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// Update distances for all devices from their polylines
function updateDistanceDisplay() {
  const distanceList = document.getElementById('distanceList');
  if (!distanceList) return;
  const q = (document.getElementById('distanceSearch')?.value || '').toLowerCase();
  
  distanceList.innerHTML = '';
  
  for (const deviceName in devices) {
    if (q && !deviceName.toLowerCase().includes(q)) continue;
    const dev = devices[deviceName];
    if (!dev || !dev.polyline) continue;
    
    // Calculate total distance from polyline points
    const latLngs = dev.polyline.getLatLngs();
    let totalDistance = 0;
    
    // Sum distances between consecutive points
    if (latLngs.length > 1) {
      for (let i = 1; i < latLngs.length; i++) {
        const prev = latLngs[i - 1];
        const curr = latLngs[i];
        const dist = calculateDistance(prev.lat, prev.lng, curr.lat, curr.lng);
        totalDistance += dist;
      }
    }
    
    // Update device distance
    dev.distanceCovered = totalDistance;
    
    // Create distance item
    const item = document.createElement('div');
    item.className = 'distance-item';
    item.innerHTML = `
      <div class="distance-item-name">${deviceName}</div>
      <div>
        <span class="distance-item-value">${totalDistance.toFixed(2)}</span>
        <span class="distance-item-unit">km</span>
      </div>
    `;
    
    // Right-click to reset distance
    item.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const choice = prompt(
        `Options for ${deviceName}:\n` +
        `1 = Reset distance (keep all data)\n` +
        `2 = Keep latest only (delete old points)\n` +
        `3 = Delete device data (remove all points)\n\n` +
        `Enter 1, 2, or 3:`
      );

      if (choice === '1') {
        dev.distanceCovered = 0;
        dev.lastCalculatedPoint = null;
        console.log(`üîÑ Distance reset for ${deviceName}`);
        updateDistanceDisplay();
        return;
      }

      if (choice === '2') {
        clearDeviceData(deviceName, true).then(() => {
          console.log(`üóëÔ∏è Cleared history for ${deviceName}, kept latest`);
        });
        return;
      }

      if (choice === '3') {
        if (confirm(`Delete ALL data for ${deviceName}? This cannot be undone.`)) {
          clearDeviceData(deviceName, false).then(() => {
            console.log(`üóëÔ∏è Deleted all data for ${deviceName}`);
          });
        }
      }
    });
    
    distanceList.appendChild(item);
  }
}

async function updateStats() {
  // clear any pending calls
  if (updateStatsTimeout) clearTimeout(updateStatsTimeout);
  
  // debounce: wait 500ms before running to let all routes load
  updateStatsTimeout = setTimeout(async () => {
    const now = Date.now();
    const deviceEntriesArray = Object.entries(devices);

    const activeDevices = deviceEntriesArray.length;
    let onlineDevices = 0;
    let offlineDevices = 0;

    for (const [devName, dev] of deviceEntriesArray) {
      const offline = (now - dev.lastSeen) > OFFLINE_MS;
      if (offline) offlineDevices += 1;
      else onlineDevices += 1;

      if (dev.isOffline === undefined) {
        dev.isOffline = offline;
      } else if (dev.isOffline !== offline) {
        dev.isOffline = offline;
        addTimelineEvent(offline ? 'Signal Lost' : 'Signal Restored', offline ? 'No updates' : 'Updates resumed', devName);
      }
    }

    // total checkpoints: sum from routesCache
    let totalCheckpoints = 0;
    for (const devId in routesCache) {
      totalCheckpoints += Object.keys(routesCache[devId].checkpoints || {}).length;
    }

    // compute GLOBAL completed/remaining/progress across ALL devices and checkpoints
    let completed = 0, remaining = 0, pct = 0;
    try {
      const res = await computeGlobalCompletion(10);
      completed = res.completed;
      remaining = res.remaining;
      pct = res.pct;
      totalCheckpoints = res.total; // sync total from global compute
      console.log(`‚úÖ FINAL Global completion: ${completed}/${res.total} (${pct}%)`);
    } catch (e) {
      console.error('computeGlobalCompletion failed', e);
    }

    // Update all stat elements
    document.getElementById('deviceCount').textContent = activeDevices;
    document.getElementById('activeDevices').textContent = activeDevices;
    document.getElementById('onlineDevices').textContent = onlineDevices;
    document.getElementById('offlineDevices').textContent = offlineDevices;
    document.getElementById('totalCheckpoints').textContent = totalCheckpoints;
    document.getElementById('completedTasks').textContent = completed;
    document.getElementById('remainingTasks').textContent = remaining;
    document.getElementById('geofenceCount').textContent = Object.keys(geofencesCache).length;

    // update progress bar UI
    const progressEl = document.getElementById('overallProgress');
    const percentLabel = document.getElementById('progressPercent');
    if (progressEl) progressEl.style.width = `${pct}%`;
    if (percentLabel) percentLabel.textContent = `${pct}%`;
  }, 500); // wait 500ms after last updateStats call
}

// Add this helper function before updateStats():
function getGeofenceName(lat, lng) {
  for (const id in geofencesCache) {
    const g = geofencesCache[id];
    if (!g || !Array.isArray(g.coords)) continue;
    if (pointInPolygon(lat, lng, g.coords)) return g.name || 'Geofence';
  }
  return 'Out of any';
}

// ============ FLAG MANAGEMENT ============
function createFlagIcon() {
  return L.divIcon({
    className: 'custom-flag-marker',
    html: '<div class="flag-icon"></div>',
    iconSize: [16, 24],
    iconAnchor: [8, 24]
  });
}

// ============ FIREBASE LISTENERS ============
// Support both legacy devices/{deviceName}: {lat,lng} and new devices/{deviceName}/{pushKey}: {lat,lng}
db.ref('devices').on('value', snapshot => {
  const all = snapshot.val() || {};
  const now = Date.now();

  console.log('üìç Firebase devices listener triggered. Raw devices tree:', all);

  // Build a normalized map: { deviceName: latestPoint, points: [[lat,lng], ...] }
  const normalized = {};
  for (const name in all) {
    const node = all[name];
    if (!node) continue;

    // Case A: legacy flat object { lat, lng, speed, ... }
    const flat = coerceCoord(node);
    if (flat) {
      normalized[name] = { latest: flat, points: [[flat.lat, flat.lng]] };
      continue;
    }

    // Case B: new push-key structure { "-Ok3RI...": {lat,lng,...}, "-Ok3RQ...": {...} }
    const children = Object.values(node)
      .map((p, idx) => {
        const c = coerceCoord(p);
        return c ? { ...c, _sort: coordSortValue(c, idx) } : null;
      })
      .filter(Boolean)
      .sort((a, b) => a._sort - b._sort);

    if (children.length === 0) continue;

    const latest = children[children.length - 1];
    const points = children.map(p => [p.lat, p.lng]);
    normalized[name] = { latest, points };
  }

  console.log('üìç Normalized device payload:', normalized);

  // Update/create markers from normalized data
  for (const name in normalized) {
    const { latest, points } = normalized[name];
    if (!latest || typeof latest.lat !== 'number' || typeof latest.lng !== 'number') continue;

    if (!devices[name]) {
      console.log(`‚úÖ Creating new device marker for: ${name}`);
      const marker = L.marker([latest.lat, latest.lng]).addTo(map);
      marker.bindPopup(`<b>${name}</b><br>Loading...`);

      const polyline = L.polyline(points, {
        color: '#00e6ff',
        weight: 2,
        opacity: 0.8
      }).addTo(map);

      devices[name] = {
        marker,
        polyline,
        lastSeen: now,
        data: latest,
        buffer: [],
        distanceCovered: 0,
        lastCalculatedPoint: null,
        hasFit: false,
        geofence: ['Zone A', 'Zone B', 'Zone C', 'Zone D'][Math.floor(Math.random() * 4)]
      };

      marker.on('click', () => { selectDevice(name); toggleCard('devicesCard'); });

      // Right-click to delete old coordinates from Firebase, keeping only current location
      marker.on('contextmenu', () => {
        if (confirm(`Delete all past coordinates for ${name}? (Keep only current location)`)) {
          clearDeviceData(name, true).then(() => {
            console.log(`üóëÔ∏è Deleted old coordinates for ${name}, kept latest`);
          });
        }
      });
    } else {
      // update
      devices[name].marker.setLatLng([latest.lat, latest.lng]);
      devices[name].lastSeen = now;
      devices[name].data = latest;
      devices[name].polyline.setLatLngs(points);
      devices[name].buffer.push({ time: now, lat: latest.lat, lng: latest.lng, alt: latest.alt, speed: latest.spd ?? latest.speed });
      if (devices[name].buffer.length > 100) devices[name].buffer.shift();
    }

    // Timeline events: geofence transitions + speed spikes
    const currentGeofence = getGeofenceName(latest.lat, latest.lng);
    if (devices[name].lastGeofence && devices[name].lastGeofence !== currentGeofence) {
      const type = currentGeofence === 'Out of any' ? 'Geofence Exit' : 'Geofence Enter';
      addTimelineEvent(type, `${devices[name].lastGeofence} ‚Üí ${currentGeofence}`, name);
    } else if (!devices[name].lastGeofence && currentGeofence !== 'Out of any') {
      addTimelineEvent('Geofence Enter', currentGeofence, name);
    }
    devices[name].lastGeofence = currentGeofence;

    const currentSpeed = Number(latest.spd ?? latest.speed ?? 0);
    const prevSpeed = Number(devices[name].lastSpeed ?? 0);
    if (prevSpeed <= SPEED_SPIKE_KMH && currentSpeed > SPEED_SPIKE_KMH) {
      addTimelineEvent('Speed Spike', `${currentSpeed.toFixed(1)} km/h`, name);
    }
    devices[name].lastSpeed = currentSpeed;

    // keep popup content in sync with latest data
    updateDevicePopup(name, latest);

    if (!devices[name].hasFit && points.length > 1) {
      try {
        map.fitBounds(devices[name].polyline.getBounds(), { maxZoom: 17 });
        devices[name].hasFit = true;
      } catch (e) {
        console.warn('fitBounds failed', e);
      }
    }
  }

  // Remove devices that no longer exist
  for (const name in devices) {
    if (!normalized[name]) {
      try { map.removeLayer(devices[name].marker); map.removeLayer(devices[name].polyline); } catch(e) {}
      delete devices[name];
    }
  }

  console.log(`üìä Total devices in memory: ${Object.keys(devices).length}`);
  renderDeviceList(document.getElementById('deviceSearch').value);
  updateDistanceDisplay();
  updateStats();
}, error => { console.error('‚ùå Firebase devices listener error:', error); });

// Flags listener
db.ref('flags').on('value', snapshot => {
  const all = snapshot.val() || {};
  
  // Clear existing flags
  Object.values(flags).forEach(flag => {
    map.removeLayer(flag);
  });
  Object.keys(flags).forEach(key => delete flags[key]);
  
  // Add new flags
  for (const id in all) {
    const f = all[id];
    const flagIcon = createFlagIcon();
    const marker = L.marker([f.lat, f.lng], {
      icon: flagIcon,
      title: f.label || 'Checkpoint'
    }).addTo(map);
    
    marker.bindPopup(`
      <b>${f.label || 'Checkpoint'}</b><br>
      ${f.lat.toFixed(6)}, ${f.lng.toFixed(6)}<br>
      ${f.assignedTo ? `Assigned to: ${f.assignedTo}` : 'All devices'}
    `);
    
    marker.bindTooltip(f.label || 'Checkpoint', {
      permanent: true,
      direction: 'right',
      className: 'flag-label'
    }).openTooltip();
    
    marker.on('contextmenu', () => {
      if (confirm('Remove this checkpoint?')) {
        db.ref(`flags/${id}`).remove();
      }
    });
    
    flags[id] = marker;
  }
  
  updateStats();
});

// ROUTES rendering: dashed polyline per device
const routes = {};
const routeColors = {};
function getColorForDevice(id){
  if(routeColors[id]) return routeColors[id];
  const palette = ['#00e6ff','#00ff9d','#9d4dff','#ffb300','#ff3d71','#00ccff','#00e676','#7c4dff'];
  routeColors[id] = palette[Object.keys(routeColors).length % palette.length];
  return routeColors[id];
}

// Listen for devices' routes
db.ref('routes').on('child_added', deviceSnap => {
  const deviceId = deviceSnap.key;
  if (routes[deviceId]) return;
  const color = getColorForDevice(deviceId);
  const poly = L.polyline([], {
    color,
    weight: 3,
    opacity: 0.9,
    dashArray: '8 6'
  }).addTo(map);

  routes[deviceId] = { poly, markers: {} };

  const cpsRef = db.ref(`routes/${deviceId}/default/checkpoints`);
  // add existing + future checkpoints
  cpsRef.on('child_added', cpSnap => {
    const cp = cpSnap.val();
    const id = cpSnap.key;
    // add to polyline (order maintained by seq when rebuilding)
    routes[deviceId].poly.addLatLng([cp.lat, cp.lng]);

    // marker for checkpoint
    const marker = L.marker([cp.lat, cp.lng], {
      icon: createFlagIcon(),
      title: cp.label || 'Checkpoint'
    }).addTo(map);

    marker.bindTooltip(cp.label || 'Checkpoint', {
      permanent: true,
      direction: 'right',
      className: 'flag-label'
    }).openTooltip();

    marker.on('contextmenu', () => {
      if (confirm('Remove this checkpoint?')) {
        db.ref(`routes/${deviceId}/default/checkpoints/${id}`).remove();
      }
    });

    routes[deviceId].markers[id] = marker;
  });

  // when one checkpoint removed - remove marker and rebuild polyline
  cpsRef.on('child_removed', cpSnap => {
    const id = cpSnap.key;
    if (routes[deviceId].markers[id]) {
      map.removeLayer(routes[deviceId].markers[id]);
      delete routes[deviceId].markers[id];
    }
    cpsRef.once('value').then(s => {
      const pts = [];
      s.forEach(c => pts.push([c.val().lat, c.val().lng]));
      routes[deviceId].poly.setLatLngs(pts);
    });
  });
});

// Remove device route when device removed
db.ref('routes').on('child_removed', deviceSnap => {
  const deviceId = deviceSnap.key;
  if (routes[deviceId]) {
    try { map.removeLayer(routes[deviceId].poly); } catch(e){}
    Object.values(routes[deviceId].markers).forEach(m => { try { map.removeLayer(m); } catch(e){} });
    delete routes[deviceId];
  }
});

// Populate geofencesCache from DB
db.ref('geofences').on('child_added', snap => {
  geofencesCache[snap.key] = snap.val();
  console.log('Geofence added:', snap.key);
});
db.ref('geofences').on('child_changed', snap => {
  geofencesCache[snap.key] = snap.val();
});
db.ref('geofences').on('child_removed', snap => {
  delete geofencesCache[snap.key];
});

// --- geometry helpers (add these) ---
function distanceMeters(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = v => v * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// polygon contains point (polygon: [[lat,lng], ...])
function pointInPolygon(lat, lng, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0], yi = polygon[i][1];
    const xj = polygon[j][0], yj = polygon[j][1];
    const intersect = ((yi > lng) !== (yj > lng)) &&
      (lat < (xj - xi) * (lng - yi) / (yj - yi + 0.0) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// Search listeners for left panels
document.getElementById('distanceSearch')?.addEventListener('input', updateDistanceDisplay);
document.getElementById('timelineSearch')?.addEventListener('input', renderTimeline);

// ============ TIMELINE + SIGNAL HELPERS ============
const timelineEvents = [];
const TIMELINE_MAX = 60;
const SPEED_SPIKE_KMH = 15;

function formatAge(ms) {
  if (ms < 1000) return '0s';
  const s = Math.floor(ms / 1000);
  if (s < 60) return `${s}s`;
  const m = Math.floor(s / 60);
  const r = s % 60;
  return `${m}m ${r}s`;
}

function getFixStatus(hdop) {
  if (hdop === null || hdop === undefined || Number.isNaN(Number(hdop))) return { label: 'Unknown', cls: 'fix-unknown' };
  const v = Number(hdop);
  if (v <= 1.5) return { label: 'Good', cls: 'fix-good' };
  if (v <= 3) return { label: 'Degraded', cls: 'fix-warn' };
  return { label: 'Poor', cls: 'fix-bad' };
}

function addTimelineEvent(type, message, deviceName) {
  const now = new Date();
  const time = now.toLocaleTimeString();
  timelineEvents.unshift({ time, type, message, deviceName });
  if (timelineEvents.length > TIMELINE_MAX) timelineEvents.pop();
  renderTimeline();
}

function renderTimeline() {
  const list = document.getElementById('timelineList');
  if (!list) return;
  const q = (document.getElementById('timelineSearch')?.value || '').toLowerCase();
  const filtered = q
    ? timelineEvents.filter(ev =>
        (ev.message || '').toLowerCase().includes(q) ||
        (ev.type || '').toLowerCase().includes(q) ||
        (ev.deviceName || '').toLowerCase().includes(q)
      )
    : timelineEvents;

  list.innerHTML = filtered.map(ev => `
    <div class="timeline-item">
      <div class="timeline-time">${ev.time}</div>
      <div class="timeline-body">
        <div class="timeline-type">${ev.type}</div>
        <div class="timeline-msg">${ev.deviceName ? `[${ev.deviceName}] ` : ''}${ev.message}</div>
      </div>
    </div>
  `).join('');
}

function buildSparkline(values, width = 220, height = 40) {
  if (!values || values.length < 2) return '';
  const min = Math.min(...values);
  const max = Math.max(...values);
  const span = max - min || 1;
  const step = width / (values.length - 1);
  const points = values.map((v, i) => {
    const x = (i * step).toFixed(1);
    const y = (height - ((v - min) / span) * height).toFixed(1);
    return `${x},${y}`;
  }).join(' ');
  return `
    <svg class="dp-sparkline" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
      <polyline points="${points}" />
    </svg>
  `;
}

async function updateDevicePopup(name, latest) {
  const dev = devices[name];
  if (!dev || !latest) return;

  const lat = latest.lat;
  const lng = latest.lng;
  const speedVal = latest.spd ?? latest.speed ?? 0;
  const altVal = latest.alt ?? 0;
  const hdopVal = latest.hdop ?? 'N/A';
  const geofenceName = getGeofenceName(lat, lng);
  const fix = getFixStatus(latest.hdop);
  const age = formatAge(Date.now() - dev.lastSeen);

  let counts = { total: 0, completed: 0, remaining: 0 };
  try {
    counts = await computeCheckpointCounts(name, lat, lng, 10);
  } catch (e) {
    console.warn('updateDevicePopup checkpoints failed', e);
  }
  const pct = counts.total > 0 ? Math.round((counts.completed / counts.total) * 100) : 0;
  const speeds = dev.buffer.slice(-30).map(p => Number(p.speed ?? p.spd ?? 0));
  const sparkline = buildSparkline(speeds);

  dev.marker.setPopupContent(`
    <div class="device-popup">
      <div class="dp-header">
        <span class="dp-title">${name}</span>
        <span class="dp-status">LIVE</span>
      </div>

      <div class="dp-progress">
        <div class="dp-progress-row">
          <span>Progress</span>
          <span>${pct}%</span>
        </div>
        <div class="dp-progress-bar">
          <div class="dp-progress-fill" style="width:${pct}%"></div>
        </div>
      </div>

      <div class="dp-fix">
        <span>Fix</span>
        <strong class="${fix.cls}">${fix.label}</strong>
        <em>‚Ä¢ ${age} ago</em>
      </div>

      <div class="dp-grid">
        <div class="dp-item"><span>Speed</span><strong>${Number(speedVal).toFixed(1)} km/h</strong></div>
        <div class="dp-item"><span>Alt</span><strong>${Number(altVal).toFixed(1)} m</strong></div>
        <div class="dp-item"><span>HDOP</span><strong>${hdopVal}</strong></div>
        <div class="dp-item"><span>Checkpoints</span><strong>${counts.completed}/${counts.total}</strong></div>
      </div>

      ${sparkline ? `<div class="dp-sparkline-wrap">${sparkline}</div>` : ''}

      <div class="dp-coords">
        <div><span>Lat</span><strong>${lat.toFixed(6)}</strong></div>
        <div><span>Lng</span><strong>${lng.toFixed(6)}</strong></div>
      </div>

      <div class="dp-footer">
        <span>Geofence</span>
        <strong>${geofenceName}</strong>
      </div>
    </div>
  `);
}
function clearDeviceData(deviceName, keepLatest) {
  return db.ref(`devices/${deviceName}`).once('value').then(snap => {
    const coordsObj = snap.val() || {};
    const entries = Object.entries(coordsObj);

    if (!keepLatest) {
      return db.ref(`devices/${deviceName}`).remove();
    }

    let latestKey = null;
    let latestCoord = null;
    for (const [key, coord] of entries) {
      const c = coerceCoord(coord);
      if (c) {
        if (!latestCoord || coordSortValue(c, 0) > coordSortValue(latestCoord, 0)) {
          latestKey = key;
          latestCoord = c;
        }
      }
    }

    for (const [key, coord] of entries) {
      if (key !== latestKey && coerceCoord(coord)) {
        db.ref(`devices/${deviceName}/${key}`).remove();
      }
    }

    if (devices[deviceName]) {
      const ll = latestCoord ? [latestCoord.lat, latestCoord.lng] : [];
      devices[deviceName].polyline.setLatLngs(ll.length ? [ll] : []);
      if (devices[deviceName].trackLayer) {
        devices[deviceName].trackLayer.clearLayers();
        if (ll.length) {
          L.circleMarker(ll, {
            radius: 3,
            weight: 1,
            color: '#00e6ff',
            fillColor: '#00e6ff',
            fillOpacity: 0.6
          }).addTo(devices[deviceName].trackLayer);
        }
      }
      devices[deviceName].distanceCovered = 0;
      devices[deviceName].lastCalculatedPoint = null;
      updateDistanceDisplay();
    }
  });
}

// --- routesCache population (so stats / devices list see checkpoints) ---
// Use 'once' + 'child_added' listeners instead of 'on value' to avoid premature recalculations
db.ref('routes').on('child_added', deviceSnap => {
  const deviceId = deviceSnap.key;
  if (!routesCache[deviceId]) {
    routesCache[deviceId] = { checkpoints: {} };
    
    const cpsRef = db.ref(`routes/${deviceId}/default/checkpoints`);
    
    // Load initial checkpoints once
    cpsRef.once('value', s => {
      const val = s.val() || {};
      routesCache[deviceId].checkpoints = val;
      console.log(`Loaded ${Object.keys(val).length} checkpoints for ${deviceId}`);
      updateStats();
      renderDeviceList(document.getElementById('deviceSearch').value);
    });
    
    // Listen for new/changed checkpoints after initial load
    cpsRef.on('child_added', cpSnap => {
      routesCache[deviceId].checkpoints[cpSnap.key] = cpSnap.val();
      updateStats();
      renderDeviceList(document.getElementById('deviceSearch').value);
    });
    
    cpsRef.on('child_changed', cpSnap => {
      routesCache[deviceId].checkpoints[cpSnap.key] = cpSnap.val();
      updateStats();
    });
    
    cpsRef.on('child_removed', cpSnap => {
      delete routesCache[deviceId].checkpoints[cpSnap.key];
      updateStats();
      renderDeviceList(document.getElementById('deviceSearch').value);
    });
  }
});

db.ref('routes').on('child_removed', deviceSnap => {
  const deviceId = deviceSnap.key;
  delete routesCache[deviceId];
  updateStats();
  renderDeviceList(document.getElementById('deviceSearch').value);
});

// --- per-device checkpoint computation ---
async function computeCheckpointCounts(deviceName, deviceLat, deviceLng, radiusM = 10) {
  const result = { total: 0, completed: 0, remaining: 0, completedList: {} };
  const routeNode = routesCache[deviceName];
  if (!routeNode || !routeNode.checkpoints) return result;
  const cpsEntries = Object.entries(routeNode.checkpoints);
  result.total = cpsEntries.length;
  if (result.total === 0) return result;

  // check current proximity
  for (const [id, cp] of cpsEntries) {
    if (!cp || typeof cp.lat !== 'number' || typeof cp.lng !== 'number') continue;
    if (distanceMeters(deviceLat, deviceLng, cp.lat, cp.lng) <= radiusM) {
      result.completed++;
      result.completedList[id] = true;
    }
  }

  // check history for checkpoints not yet marked completed
  const remainingToCheck = cpsEntries.filter(([id]) => !result.completedList[id]);
  if (remainingToCheck.length === 0) {
    result.remaining = result.total - result.completed;
    return result;
  }

  const historyPoints = await fetchHistory(deviceName);
  if (historyPoints.length === 0) {
    result.remaining = result.total - result.completed;
    return result;
  }

  for (const [id, cp] of remainingToCheck) {
    for (const hp of historyPoints) {
      if (distanceMeters(hp.lat, hp.lng, cp.lat, cp.lng) <= radiusM) {
        result.completed++;
        result.completedList[id] = true;
        break;
      }
    }
  }

  result.remaining = result.total - result.completed;
  return result;
}

// --- render device list and populate deviceSelect ---
async function renderDeviceList(filter = '') {
  const container = document.getElementById('deviceList');
  const select = document.getElementById('deviceSelect');
  const countEl = document.getElementById('deviceCount');
  
  if (!container || !select) {
    console.error('‚ùå Device list container or select element not found');
    return;
  }

  // clear select (keep first "All Devices")
  while (select.options.length > 1) select.remove(1);
  container.innerHTML = '';

  const now = Date.now();
  const deviceEntries = Object.entries(devices);

  console.log(`üìã renderDeviceList called with ${deviceEntries.length} devices, filter: "${filter}"`);

  let matchCount = 0;
  for (const [name, dev] of deviceEntries) {
    if (filter && !name.toLowerCase().includes(filter.toLowerCase())) continue;
    
    matchCount++;
    const ageSec = Math.round((now - dev.lastSeen) / 1000);
    const offline = (now - dev.lastSeen) > OFFLINE_MS;
    const isActive = selectedDevice === name;
    const fix = getFixStatus(dev.data?.hdop);

    // add to select options
    const option = new Option(name, name);
    select.add(option);

    // build UI item
    const item = document.createElement('div');
    item.className = `device-item ${offline ? 'offline' : ''} ${isActive ? 'active' : ''}`;
    item.dataset.device = name;

    item.innerHTML = `
      <div class="device-header">
        <div class="device-name">
          <span class="status-indicator"></span>
          <strong>${name}</strong>
        </div>
        <div class="device-time">${ageSec}s ago</div>
      </div>

      <div class="device-stats">
        <div class="stat-row">
          <span class="stat-label">Speed:</span>
          <span class="stat-value">${dev.data?.speed?.toFixed ? dev.data.speed.toFixed(1) : '0'} km/h</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Altitude:</span>
          <span class="stat-value">${dev.data?.alt?.toFixed ? dev.data.alt.toFixed(1) : '0'} m</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Fix:</span>
          <span class="stat-value ${fix.cls}">${fix.label}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Completed:</span>
          <span class="stat-value" id="completed-${name}">...</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Remaining:</span>
          <span class="stat-value" id="remaining-${name}">...</span>
        </div>
      </div>

      <div class="geofence-info">
        <span id="geofence-${name}">Geofence: ...</span>
      </div>

      <div class="task-progress">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-${name}" style="width:0%"></div>
        </div>
        <div class="progress-text">
          <span>Progress</span>
          <span id="progress-text-${name}">0%</span>
        </div>
      </div>
    `;

    item.addEventListener('click', () => selectDevice(name));
    container.appendChild(item);

    // async compute per-device counts and update UI
    (async () => {
      try {
        const lat = dev.data?.lat;
        const lng = dev.data?.lng;
        if (typeof lat !== 'number' || typeof lng !== 'number') {
          document.getElementById(`completed-${name}`).textContent = '0';
          document.getElementById(`remaining-${name}`).textContent = '0';
          document.getElementById(`geofence-${name}`).textContent = 'Geofence: Unknown';
          return;
        }

        const counts = await computeCheckpointCounts(name, lat, lng, 10);
        document.getElementById(`completed-${name}`).textContent = counts.completed;
        document.getElementById(`remaining-${name}`).textContent = counts.remaining;
        const pct = counts.total > 0 ? Math.round((counts.completed / counts.total) * 100) : 0;
        const fill = document.getElementById(`progress-${name}`);
        const ptext = document.getElementById(`progress-text-${name}`);
        if (fill) { fill.style.width = `${pct}%`; }
        if (ptext) { ptext.textContent = `${pct}%`; }
        const gfName = getGeofenceName(lat, lng);
        const gfEl = document.getElementById(`geofence-${name}`);
        if (gfEl) gfEl.textContent = `Geofence: ${gfName}`;
      } catch (err) {
        console.error('renderDeviceList per-device update error for', name, err);
      }
    })();
  }
  
  // Update device count in header
  if (countEl) {
    countEl.textContent = matchCount;
    console.log(`‚úÖ Device count updated: ${matchCount}`);
  }
}

// ensure device search filters
document.getElementById('deviceSearch').addEventListener('input', (e) => {
  renderDeviceList(e.target.value);
});

// Call renderDeviceList once at startup if devices already loaded
console.log('üöÄ Initial renderDeviceList call on page load');
renderDeviceList();

// small global error handler to help debugging runtime issues
window.addEventListener('error', (ev) => {
  console.error('Global error caught:', ev.message, 'at', ev.filename + ':' + ev.lineno + ':' + ev.colno);
});

// debug logs for listeners
console.log('Registering Firebase listeners...');
db.ref('devices').on('value', snapshot => console.log('devices snapshot received'));
db.ref('routes').on('value', snapshot => console.log('routes snapshot received'));
db.ref('geofences').on('value', snapshot => console.log('geofences snapshot received'));

// Track completed checkpoints visually
const completedCheckpoints = new Set(); // { "deviceId_cpId" }

// Mark checkpoint as completed (visual indicator)
function markCheckpointCompleted(deviceId, cpId, marker) {
  const key = `${deviceId}_${cpId}`;
  if (completedCheckpoints.has(key)) return;
  completedCheckpoints.add(key);
  
  // Change marker appearance - add checkmark
  const checkmarkIcon = L.divIcon({
    className: 'custom-flag-marker',
    html: '<div class="flag-icon" style="opacity:0.5;"></div><div style="position:absolute;top:-2px;left:2px;color:#00ff9d;font-weight:bold;font-size:14px;">‚úì</div>',
    iconSize: [16, 24],
    iconAnchor: [8, 24]
  });
  marker.setIcon(checkmarkIcon);
  marker.setOpacity(0.6);

  const cp = routesCache[deviceId]?.checkpoints?.[cpId];
  const label = cp?.label || 'Checkpoint';
  addTimelineEvent('Checkpoint Reached', label, deviceId);
}

// Update completed checkpoints based on device proximity
async function updateCompletedCheckpoints() {
  for (const deviceName in devices) {
    const dev = devices[deviceName];
    const lat = dev.data?.lat;
    const lng = dev.data?.lng;
    if (typeof lat !== 'number' || typeof lng !== 'number') continue;

    const routeNode = routesCache[deviceName];
    if (!routeNode || !routeNode.checkpoints) continue;

    // check current proximity
    for (const [cpId, cp] of Object.entries(routeNode.checkpoints)) {
      if (!cp || typeof cp.lat !== 'number' || typeof cp.lng !== 'number') continue;
      if (distanceMeters(lat, lng, cp.lat, cp.lng) <= 10) {
        const marker = routes[deviceName]?.markers?.[cpId];
        if (marker) markCheckpointCompleted(deviceName, cpId, marker);
      }
    }
  }

  // check history for past proximity
  for (const deviceName in devices) {
    const routeNode = routesCache[deviceName];
    if (!routeNode || !routeNode.checkpoints) continue;

    const historyPoints = await fetchHistory(deviceName);
    if (historyPoints.length === 0) continue;

    for (const [cpId, cp] of Object.entries(routeNode.checkpoints)) {
      if (!cp || typeof cp.lat !== 'number' || typeof cp.lng !== 'number') continue;
      const key = `${deviceName}_${cpId}`;
      if (completedCheckpoints.has(key)) continue;

      for (const hp of historyPoints) {
        if (distanceMeters(hp.lat, hp.lng, cp.lat, cp.lng) <= 10) {
          const marker = routes[deviceName]?.markers?.[cpId];
          if (marker) markCheckpointCompleted(deviceName, cpId, marker);
          break;
        }
      }
    }
  }
}

// Call this periodically to update completed checkpoints
setInterval(updateCompletedCheckpoints, 5000);
updateCompletedCheckpoints();

// ============ CHECKPOINT DELETION ============
// Update the checkpoint marker context menu to allow deletion
db.ref('routes').on('child_added', deviceSnap => {
  const deviceId = deviceSnap.key;
  if (routes[deviceId]) return;
  const color = getColorForDevice(deviceId);
  const poly = L.polyline([], {
    color,
    weight: 3,
    opacity: 0.9,
    dashArray: '8 6'
  }).addTo(map);

  routes[deviceId] = { poly, markers: {} };

  const cpsRef = db.ref(`routes/${deviceId}/default/checkpoints`);
  cpsRef.on('child_added', cpSnap => {
    const cp = cpSnap.val();
    const id = cpSnap.key;
    routes[deviceId].poly.addLatLng([cp.lat, cp.lng]);

    const marker = L.marker([cp.lat, cp.lng], {
      icon: createFlagIcon(),
      title: cp.label || 'Checkpoint'
    }).addTo(map);

    marker.bindTooltip(cp.label || 'Checkpoint', {
      permanent: true,
      direction: 'right',
      className: 'flag-label'
    }).openTooltip();

    // Right-click to delete checkpoint
    marker.on('contextmenu', () => {
      if (confirm(`Delete checkpoint "${cp.label || 'Checkpoint'}"?`)) {
        db.ref(`routes/${deviceId}/default/checkpoints/${id}`).remove()
          .then(() => {
            console.log('Checkpoint deleted');
            updateStats();
          })
          .catch(err => console.error('Failed to delete checkpoint', err));
      }
    });

    routes[deviceId].markers[id] = marker;
  });

  cpsRef.on('child_removed', cpSnap => {
    const id = cpSnap.key;
    if (routes[deviceId].markers[id]) {
      map.removeLayer(routes[deviceId].markers[id]);
      delete routes[deviceId].markers[id];
    }
    cpsRef.once('value').then(s => {
      const pts = [];
      s.forEach(c => pts.push([c.val().lat, c.val().lng]));
      routes[deviceId].poly.setLatLngs(pts);
    });
  });
});

function deleteCheckpoint(deviceId, cpId) {
  db.ref(`routes/${deviceId}/default/checkpoints/${cpId}`).remove()
    .then(() => {
      console.log('Checkpoint deleted');
      map.closePopup();
      updateStats();
    })
    .catch(err => console.error('Failed to delete checkpoint', err));
}

// ============ GEOFENCE DELETION ============
// Update geofence rendering to include delete buttons
const geofenceMarkers = {}; // { gfId: polygon }
let showGeofences = true;

function setGeofenceVisibility(show) {
  showGeofences = show;
  for (const id in geofenceMarkers) {
    const layer = geofenceMarkers[id];
    if (!layer) continue;
    if (showGeofences) {
      if (!map.hasLayer(layer)) layer.addTo(map);
    } else {
      if (map.hasLayer(layer)) map.removeLayer(layer);
    }
  }
}

db.ref('geofences').on('child_added', snap => {
  const gfId = snap.key;
  const g = snap.val();
  if (!g || !Array.isArray(g.coords)) return;
  
  const poly = L.polygon(g.coords, { 
    color: '#ff3d71', 
    fillOpacity: 0.12,
    weight: 2,
    opacity: 0.85,
    dashArray: '6 6'
  });

  poly.bindPopup(`
    <div class="geofence-popup">
      <div class="geofence-title">${g.name || 'Geofence'}</div>
      <div class="geofence-meta">Created: ${g.timestamp || 'N/A'}</div>
      <button onclick="deleteGeofence('${gfId}')" class="geofence-delete">Delete Geofence</button>
    </div>
  `);

  // Right-click to delete
  poly.on('contextmenu', () => {
    if (confirm(`Delete geofence "${g.name || 'Geofence'}"?`)) {
      deleteGeofence(gfId);
    }
  });

  geofenceMarkers[gfId] = poly;

  if (showGeofences) {
    poly.addTo(map);
  }
});

db.ref('geofences').on('child_removed', snap => {
  const gfId = snap.key;
  if (geofenceMarkers[gfId]) {
    try { map.removeLayer(geofenceMarkers[gfId]); } catch(e){}
    delete geofenceMarkers[gfId];
  }
});

function deleteGeofence(gfId) {
  db.ref(`geofences/${gfId}`).remove()
    .then(() => {
      console.log('Geofence deleted');
      map.closePopup();
      updateStats();
    })
    .catch(err => console.error('Failed to delete geofence', err));
}

// Add these functions after the selectDevice declaration (around line 950):

function selectDevice(name) {
  selectedDevice = name;
  renderDeviceList(document.getElementById('deviceSearch').value);
  
  // Center map on device
  const dev = devices[name];
  if (dev && dev.marker) {
    map.setView(dev.marker.getLatLng(), 14);
    
    // Always show latest data from current device structure
    updateDevicePopup(name, dev.data);
    dev.marker.openPopup();
  }
}

function centerOnSelectedDevice() {
  if (!selectedDevice || !devices[selectedDevice]) {
    alert('No device selected');
    return;
  }
  selectDevice(selectedDevice);
}

function setDeviceVisibility(name, visible) {
  const dev = devices[name];
  if (!dev) return;
  const action = visible ? map.addLayer.bind(map) : map.removeLayer.bind(map);
  if (dev.marker) action(dev.marker);
  if (dev.polyline) action(dev.polyline);
  if (dev.trackLayer) action(dev.trackLayer);
}

function setRouteVisibility(deviceId, visible) {
  const route = routes[deviceId];
  if (!route) return;
  const action = visible ? map.addLayer.bind(map) : map.removeLayer.bind(map);
  if (route.poly) action(route.poly);
  Object.values(route.markers || {}).forEach(m => action(m));
}

function focusOnSelectedDevice() {
  if (!selectedDevice || !devices[selectedDevice]) {
    alert('No device selected');
    return;
  }
  const dev = devices[selectedDevice];
  const focusBtn = document.getElementById('focusBtn');
  const focusIcon = document.getElementById('focusBtnIcon');

  // Toggle focus mode on/off
  if (focusMode && focusedDevice === selectedDevice) {
    // restore all
    for (const name in devices) setDeviceVisibility(name, true);
    for (const deviceId in routes) setRouteVisibility(deviceId, true);
    focusMode = false;
    focusedDevice = null;
    if (focusBtn) focusBtn.classList.remove('active');
    if (focusIcon) focusIcon.textContent = 'üéØ';
    showAllDevices();
    return;
  }

  // enable focus mode
  for (const name in devices) {
    setDeviceVisibility(name, name === selectedDevice);
  }
  for (const deviceId in routes) {
    setRouteVisibility(deviceId, deviceId === selectedDevice);
  }
  focusMode = true;
  focusedDevice = selectedDevice;
  if (focusBtn) focusBtn.classList.add('active');
  if (focusIcon) focusIcon.textContent = 'üß≠';

  if (dev?.polyline) {
    map.fitBounds(dev.polyline.getBounds(), { padding: [60, 60], maxZoom: 18 });
  } else if (dev?.marker) {
    map.setView(dev.marker.getLatLng(), 16);
  }
  updateDevicePopup(selectedDevice, dev.data);
  dev.marker?.openPopup();
}

function showAllDevices() {
  const group = new L.featureGroup(Object.values(devices).map(d => d.marker));
  if (group.getLayers().length > 0) {
    map.fitBounds(group.getBounds(), { padding: [50, 50] });
  }
}

// ============ REPORT GENERATION ============
function openReportModal() {
  const modal = document.getElementById('reportModal');
  const content = document.getElementById('reportContent');
  if (!modal || !content) return;
  content.innerHTML = buildReportHtml();
  modal.style.display = 'flex';
}

function closeReportModal() {
  const modal = document.getElementById('reportModal');
  if (modal) modal.style.display = 'none';
}

function exportFirebaseJson() {
  db.ref('/').once('value').then(snap => {
    const data = snap.val() || {};
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `gps-tracker-export-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }).catch(err => {
    console.error('Export failed', err);
    alert('Export failed. Check console for details.');
  });
}

function getDeviceSummaryRows() {
  const rows = [];
  for (const [name, dev] of Object.entries(devices)) {
    const lat = dev.data?.lat;
    const lng = dev.data?.lng;
    const speed = dev.data?.spd ?? dev.data?.speed ?? 0;
    const alt = dev.data?.alt ?? 0;
    const hdop = dev.data?.hdop ?? 'N/A';
    const age = formatAge(Date.now() - dev.lastSeen);
    const fix = getFixStatus(dev.data?.hdop).label;
    const distanceKm = dev.distanceCovered?.toFixed ? dev.distanceCovered.toFixed(2) : '0.00';

    rows.push(`
      <tr>
        <td>${name}</td>
        <td>${fix}</td>
        <td>${age}</td>
        <td>${Number(speed).toFixed(1)} km/h</td>
        <td>${Number(alt).toFixed(1)} m</td>
        <td>${hdop}</td>
        <td>${distanceKm} km</td>
        <td>${typeof lat === 'number' ? lat.toFixed(6) : '‚Äî'}</td>
        <td>${typeof lng === 'number' ? lng.toFixed(6) : '‚Äî'}</td>
      </tr>
    `);
  }
  return rows.join('');
}

function getCheckpointSummaryRows() {
  const rows = [];
  for (const deviceId in routesCache) {
    const cps = routesCache[deviceId]?.checkpoints || {};
    const total = Object.keys(cps).length;
    let completed = 0;
    for (const cpId in cps) {
      if (completedCheckpoints.has(`${deviceId}_${cpId}`)) completed++;
    }
    const remaining = total - completed;
    const pct = total > 0 ? Math.round((completed / total) * 100) : 0;
    rows.push(`
      <tr>
        <td>${deviceId}</td>
        <td>${completed}</td>
        <td>${remaining}</td>
        <td>${total}</td>
        <td>${pct}%</td>
      </tr>
    `);
  }
  return rows.join('');
}

function getTimelineRows() {
  return timelineEvents.slice(0, 20).map(ev => `
    <tr>
      <td>${ev.time}</td>
      <td>${ev.type}</td>
      <td>${ev.deviceName || '‚Äî'}</td>
      <td>${ev.message}</td>
    </tr>
  `).join('');
}

function buildReportHtml() {
  const now = new Date();
  const deviceCount = Object.keys(devices).length;
  const geofenceCount = Object.keys(geofencesCache).length;
  let totalCheckpoints = 0;
  for (const devId in routesCache) totalCheckpoints += Object.keys(routesCache[devId].checkpoints || {}).length;

  return `
    <div class="report">
      <div class="report-header">
        <div>
          <div class="report-title">MISSION SUMMARY REPORT</div>
          <div class="report-subtitle">Generated ${now.toLocaleString()}</div>
        </div>
        <div class="report-badge">CONFIDENTIAL</div>
      </div>

      <div class="report-section">
        <div class="report-section-title">Mission Overview</div>
        <div class="report-grid">
          <div><span>Devices</span><strong>${deviceCount}</strong></div>
          <div><span>Checkpoints</span><strong>${totalCheckpoints}</strong></div>
          <div><span>Geofences</span><strong>${geofenceCount}</strong></div>
          <div><span>Timeline Events</span><strong>${timelineEvents.length}</strong></div>
        </div>
      </div>

      <div class="report-section">
        <div class="report-section-title">Device Status</div>
        <table class="report-table">
          <thead>
            <tr>
              <th>Device</th>
              <th>Fix</th>
              <th>Last Seen</th>
              <th>Speed</th>
              <th>Alt</th>
              <th>HDOP</th>
              <th>Distance</th>
              <th>Lat</th>
              <th>Lng</th>
            </tr>
          </thead>
          <tbody>
            ${getDeviceSummaryRows() || '<tr><td colspan="9">No device data</td></tr>'}
          </tbody>
        </table>
      </div>

      <div class="report-section">
        <div class="report-section-title">Checkpoint Summary</div>
        <table class="report-table">
          <thead>
            <tr>
              <th>Device</th>
              <th>Completed</th>
              <th>Remaining</th>
              <th>Total</th>
              <th>Marks</th>
            </tr>
          </thead>
          <tbody>
            ${getCheckpointSummaryRows() || '<tr><td colspan="5">No checkpoints</td></tr>'}
          </tbody>
        </table>
      </div>

      <div class="report-section">
        <div class="report-section-title">Recent Timeline Events</div>
        <table class="report-table">
          <thead>
            <tr>
              <th>Time</th>
              <th>Event</th>
              <th>Device</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody>
            ${getTimelineRows() || '<tr><td colspan="4">No events</td></tr>'}
          </tbody>
        </table>
      </div>
    </div>
  `;
}

function downloadReportPdf() {
  const html = buildReportHtml();
  const css = document.querySelector('style') ? document.querySelector('style').innerHTML : '';

  reportWindow = window.open('', '_blank');
  if (!reportWindow) return;

  const page = `
    <html>
      <head>
        <title>Mission Summary Report</title>
        <style>
          ${css}
          body { background: #0b111a; color: #e6f7ff; font-family: 'Exo 2', Arial, sans-serif; padding: 24px; }
          .report { max-width: 1000px; margin: 0 auto; }
          .report-table { width: 100%; border-collapse: collapse; margin-top: 8px; }
          .report-table th, .report-table td { border: 1px solid rgba(120,150,180,0.35); padding: 8px; font-size: 12px; }
          .report-header { display:flex; justify-content:space-between; align-items:center; margin-bottom: 16px; }
          .report-title { font-family:'Orbitron', sans-serif; font-size: 18px; letter-spacing: 1px; }
          .report-subtitle { font-size: 12px; opacity: 0.8; }
          .report-badge { border:1px solid rgba(120,150,180,0.6); padding:4px 10px; font-size:10px; letter-spacing:1px; }
          .report-section { margin: 18px 0; }
          .report-section-title { font-family:'Orbitron', sans-serif; font-size: 13px; letter-spacing: 0.8px; margin-bottom: 6px; }
          .report-grid { display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 10px; }
          .report-grid span { display:block; font-size: 11px; opacity: 0.7; }
          .report-grid strong { font-size: 14px; }
          @media print { body { background: #fff; color: #000; } }
        </style>
      </head>
      <body>
        ${html}
      </body>
    </html>
  `;

  reportWindow.document.open();
  reportWindow.document.write(page);
  reportWindow.document.close();
  reportWindow.onload = () => reportWindow.print();
}
</script>

</body>
</html>
